// Code generated by schema-generate. DO NOT EDIT.

package schemas_package_json

import (
    "fmt"
    "encoding/json"
    "errors"
    "bytes"
)

// Bugs_object The url to your project's issue tracker and / or the email address to which issues should be reported. These are helpful for people who encounter issues with your package.
type Bugs_object struct {

  // The email address to which issues should be reported.
  Email string `json:"email,omitempty"`

  // The url to your project's issue tracker.
  Url string `json:"url,omitempty"`
}

// Config A 'config' hash can be used to set configuration parameters used in package scripts that persist across upgrades.
type Config struct {
  AdditionalProperties map[string]interface{} `json:"-"`
}

// Dependency Dependencies are specified with a simple hash of package name to version range. The version range is a string which has one or more space-separated descriptors. Dependencies can also be identified with a tarball or git URL.
type Dependency struct {
  AdditionalProperties map[string]string `json:"-"`
}

// Directories 
type Directories struct {

  // If you specify a 'bin' directory, then all the files in that folder will be used as the 'bin' hash.
  Bin string `json:"bin,omitempty"`

  // Put markdown files in here. Eventually, these will be displayed nicely, maybe, someday.
  Doc string `json:"doc,omitempty"`

  // Put example scripts in here. Someday, it might be exposed in some clever way.
  Example string `json:"example,omitempty"`

  // Tell people where the bulk of your library is. Nothing special is done with the lib folder in any way, but it's useful meta info.
  Lib string `json:"lib,omitempty"`

  // A folder that is full of man pages. Sugar to generate a 'man' array by walking the folder.
  Man string `json:"man,omitempty"`
  Test string `json:"test,omitempty"`
}

// Dist 
type Dist struct {
  Shasum string `json:"shasum,omitempty"`
  Tarball string `json:"tarball,omitempty"`
}

// Engines 
type Engines struct {
  AdditionalProperties map[string]string `json:"-"`
  Node string `json:"node,omitempty"`
}

// Esnext_object A module ID with untranspiled code that is the primary entry point to your program.
type Esnext_object struct {
  AdditionalProperties map[string]string `json:"-"`
  Browser string `json:"browser,omitempty"`
  Main string `json:"main,omitempty"`
}

// FundingWay Used to inform about ways to help fund development of the package.
type FundingWay struct {

  // The type of funding or the platform through which funding can be provided, e.g. patreon, opencollective, tidelift or github.
  Type string `json:"type,omitempty"`
  Url string `json:"url"`
}

// PackageJsonSchema 
type PackageJsonSchema struct {
  Author *Person_object `json:"author,omitempty"`
  Bin interface{} `json:"bin,omitempty"`

  // The url to your project's issue tracker and / or the email address to which issues should be reported. These are helpful for people who encounter issues with your package.
  Bugs interface{} `json:"bugs,omitempty"`

  // Array of package names that will be bundled when publishing the package.
  BundleDependencies interface{} `json:"bundleDependencies,omitempty"`

  // DEPRECATED: This field is honored, but "bundleDependencies" is the correct field name.
  BundledDependencies interface{} `json:"bundledDependencies,omitempty"`

  // A 'config' hash can be used to set configuration parameters used in package scripts that persist across upgrades.
  Config *Config `json:"config,omitempty"`

  // A list of people who contributed to this package.
  Contributors []Person_object `json:"contributors,omitempty"`

  // Specify that your code only runs on certain cpu architectures.
  Cpu []string `json:"cpu,omitempty"`
  Dependencies *Dependency `json:"dependencies,omitempty"`

  // This helps people discover your package, as it's listed in 'npm search'.
  Description string `json:"description,omitempty"`
  DevDependencies *Dependency `json:"devDependencies,omitempty"`
  Directories *Directories `json:"directories,omitempty"`
  Dist *Dist `json:"dist,omitempty"`
  EngineStrict bool `json:"engineStrict,omitempty"`
  Engines *Engines `json:"engines,omitempty"`

  // A module ID with untranspiled code that is the primary entry point to your program.
  Esnext interface{} `json:"esnext,omitempty"`

  // The "exports" field is used to restrict external access to non-exported module files, also enables a module to import itself using "name".
  Exports interface{} `json:"exports,omitempty"`

  // The 'files' field is an array of files to include in your project. If you name a folder in the array, then it will also include the files inside that folder.
  Files []string `json:"files,omitempty"`
  Funding interface{} `json:"funding,omitempty"`

  // The url to the project homepage.
  Homepage string `json:"homepage,omitempty"`

  // This helps people discover your package as it's listed in 'npm search'.
  Keywords []string `json:"keywords,omitempty"`

  // You should specify a license for your package so that people know how they are permitted to use it, and any restrictions you're placing on it.
  License interface{} `json:"license,omitempty"`

  // DEPRECATED: Instead, use SPDX expressions, like this: { "license": "ISC" } or { "license": "(MIT OR Apache-2.0)" } see: 'https://docs.npmjs.com/files/package.json#license'.
  Licenses []LicensesItems `json:"licenses,omitempty"`

  // The main field is a module ID that is the primary entry point to your program.
  Main string `json:"main,omitempty"`

  // A list of people who maintains this package.
  Maintainers []Person_object `json:"maintainers,omitempty"`

  // Specify either a single file or an array of filenames to put in place for the man program to find.
  Man interface{} `json:"man,omitempty"`

  // An ECMAScript module ID that is the primary entry point to your program.
  Module string `json:"module,omitempty"`

  // The name of the package.
  Name string `json:"name,omitempty"`
  OptionalDependencies *Dependency `json:"optionalDependencies,omitempty"`

  // Specify which operating systems your module will run on.
  Os []string `json:"os,omitempty"`

  // Overrides is used to support selective version overrides using npm, which lets you define custom package versions or ranges inside your dependencies. For yarn, use resolutions instead. See: https://docs.npmjs.com/cli/v9/configuring-npm/package-json#overrides
  Overrides *Overrides `json:"overrides,omitempty"`

  // Defines which package manager is expected to be used when working on the current project. This field is currently experimental and needs to be opted-in; see https://nodejs.org/api/corepack.html
  PackageManager string `json:"packageManager,omitempty"`
  PeerDependencies *Dependency `json:"peerDependencies,omitempty"`

  // When a user installs your package, warnings are emitted if packages specified in "peerDependencies" are not already installed. The "peerDependenciesMeta" field serves to provide more information on how your peer dependencies are utilized. Most commonly, it allows peer dependencies to be marked as optional. Metadata for this field is specified with a simple hash of the package name to a metadata object.
  PeerDependenciesMeta map[string]*PeerDependenciesMetaItem `json:"peerDependenciesMeta,omitempty"`

  // DEPRECATED: This option used to trigger an npm warning, but it will no longer warn. It is purely there for informational purposes. It is now recommended that you install any binaries as local devDependencies wherever possible.
  PreferGlobal bool `json:"preferGlobal,omitempty"`

  // If set to true, then npm will refuse to publish it.
  Private interface{} `json:"private,omitempty"`
  PublishConfig *PublishConfig `json:"publishConfig,omitempty"`
  Readme string `json:"readme,omitempty"`

  // Specify the place where your code lives. This is helpful for people who want to contribute.
  Repository interface{} `json:"repository,omitempty"`

  // Resolutions is used to support selective version resolutions using yarn, which lets you define custom package versions or ranges inside your dependencies. For npm, use overrides instead. See: https://classic.yarnpkg.com/en/docs/selective-version-resolutions
  Resolutions *Resolutions `json:"resolutions,omitempty"`

  // The 'scripts' member is an object hash of script commands that are run at various times in the lifecycle of your package. The key is the lifecycle event, and the value is the command to run at that point.
  Scripts *Scripts `json:"scripts,omitempty"`

  // When set to "module", the type field allows a package to specify all .js files within are ES modules. If the "type" field is omitted or set to "commonjs", all .js files are treated as CommonJS.
  Type string `json:"type,omitempty"`

  // Set the types property to point to your bundled declaration file.
  Types string `json:"types,omitempty"`

  // Note that the "typings" field is synonymous with "types", and could be used as well.
  Typings string `json:"typings,omitempty"`

  // Version must be parseable by node-semver, which is bundled with npm as a dependency.
  Version string `json:"version,omitempty"`

  // Defines which tools and versions are expected to be used when Volta is installed.
  Volta *Volta `json:"volta,omitempty"`

  // Allows packages within a directory to depend on one another using direct linking of local files. Additionally, dependencies within a workspace are hoisted to the workspace root when possible to reduce duplication. Note: It's also a good idea to set "private" to true when using this feature.
  Workspaces interface{} `json:"workspaces,omitempty"`
}

// LicensesItems 
type LicensesItems struct {
  Type interface{} `json:"type,omitempty"`
  Url string `json:"url,omitempty"`
}

// Overrides Overrides is used to support selective version overrides using npm, which lets you define custom package versions or ranges inside your dependencies. For yarn, use resolutions instead. See: https://docs.npmjs.com/cli/v9/configuring-npm/package-json#overrides
type Overrides struct {
}

// PackageExportsEntryObject Used to specify conditional exports, note that Conditional exports are unsupported in older environments, so it's recommended to use the fallback array option if support for those environments is a concern.
type PackageExportsEntryObject struct {

  // The module path that is resolved when no other export type matches.
  Default interface{} `json:"default,omitempty"`

  // The module path that is resolved when this specifier is imported as an ECMAScript module using an `import` declaration or the dynamic `import(...)` function.
  Import interface{} `json:"import,omitempty"`

  // The module path that is resolved when this environment is Node.js.
  Node interface{} `json:"node,omitempty"`

  // The module path that is resolved when this specifier is imported as a CommonJS module using the `require(...)` function.
  Require interface{} `json:"require,omitempty"`

  // The module path that is resolved for TypeScript types when this specifier is imported. Should be listed before other conditions.
  Types interface{} `json:"types,omitempty"`
}

// PeerDependenciesMetaItem 
type PeerDependenciesMetaItem struct {
  AdditionalProperties map[string]interface{} `json:"-"`

  // Specifies that this peer dependency is optional and should not be installed automatically.
  Optional bool `json:"optional,omitempty"`
}

// Person_object A person who has been involved in creating or maintaining this package.
type Person_object struct {
  Email string `json:"email,omitempty"`
  Name string `json:"name"`
  Url string `json:"url,omitempty"`
}

// PublishConfig 
type PublishConfig struct {
  Access string `json:"access,omitempty"`
  AdditionalProperties map[string]interface{} `json:"-"`
  Registry string `json:"registry,omitempty"`
  Tag string `json:"tag,omitempty"`
}

// Repository_object Specify the place where your code lives. This is helpful for people who want to contribute.
type Repository_object struct {
  Directory string `json:"directory,omitempty"`
  Type string `json:"type,omitempty"`
  Url string `json:"url,omitempty"`
}

// Resolutions Resolutions is used to support selective version resolutions using yarn, which lets you define custom package versions or ranges inside your dependencies. For npm, use overrides instead. See: https://classic.yarnpkg.com/en/docs/selective-version-resolutions
type Resolutions struct {
}

// Scripts The 'scripts' member is an object hash of script commands that are run at various times in the lifecycle of your package. The key is the lifecycle event, and the value is the command to run at that point.
type Scripts struct {
  AdditionalProperties map[string]string `json:"-"`
  Install string `json:"install,omitempty"`

  // Run code quality tools, e.g. ESLint, TSLint, etc.
  Lint string `json:"lint,omitempty"`
  Postinstall string `json:"postinstall,omitempty"`

  // Run AFTER the tarball has been generated and moved to its final destination.
  Postpack string `json:"postpack,omitempty"`
  Postpublish string `json:"postpublish,omitempty"`
  Postrestart string `json:"postrestart,omitempty"`
  Poststart string `json:"poststart,omitempty"`
  Poststop string `json:"poststop,omitempty"`
  Posttest string `json:"posttest,omitempty"`

  // Run AFTER the package is uninstalled.
  Postuninstall string `json:"postuninstall,omitempty"`

  // Run AFTER bump the package version.
  Postversion string `json:"postversion,omitempty"`

  // Run BEFORE the package is installed.
  Preinstall string `json:"preinstall,omitempty"`

  // run BEFORE a tarball is packed (on npm pack, npm publish, and when installing git dependencies).
  Prepack string `json:"prepack,omitempty"`

  // Run both BEFORE the package is packed and published, and on local npm install without any arguments. This is run AFTER prepublish, but BEFORE prepublishOnly.
  Prepare string `json:"prepare,omitempty"`

  // Run BEFORE the package is published (Also run on local npm install without any arguments).
  Prepublish string `json:"prepublish,omitempty"`

  // Run BEFORE the package is prepared and packed, ONLY on npm publish.
  PrepublishOnly string `json:"prepublishOnly,omitempty"`
  Prerestart string `json:"prerestart,omitempty"`
  Prestart string `json:"prestart,omitempty"`
  Prestop string `json:"prestop,omitempty"`
  Pretest string `json:"pretest,omitempty"`
  Preuninstall string `json:"preuninstall,omitempty"`
  Preversion string `json:"preversion,omitempty"`

  // Publishes a package to the registry so that it can be installed by name. See https://docs.npmjs.com/cli/v8/commands/npm-publish
  Publish string `json:"publish,omitempty"`
  Restart string `json:"restart,omitempty"`

  // Start dev server to serve application files
  Serve string `json:"serve,omitempty"`
  Start string `json:"start,omitempty"`
  Stop string `json:"stop,omitempty"`
  Test string `json:"test,omitempty"`
  Uninstall string `json:"uninstall,omitempty"`
  Version string `json:"version,omitempty"`
}

// Volta Defines which tools and versions are expected to be used when Volta is installed.
type Volta struct {

  // The value of that entry should be a path to another JSON file which also has a "volta" section
  Extends string `json:"extends,omitempty"`
}

func (strct *Config) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal any additional Properties
    for k, v := range strct.AdditionalProperties {
		if comma {
			buf.WriteString(",")
		}
        buf.WriteString(fmt.Sprintf("\"%s\":", k))
		if tmp, err := json.Marshal(v); err != nil {
			return nil, err
		} else {
			buf.Write(tmp)
		}
        comma = true
	}

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Config) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        default:
            // an additional "interface{}" value
            var additionalValue interface{}
            if err := json.Unmarshal([]byte(v), &additionalValue); err != nil {
                return err // invalid additionalProperty
            }
            if strct.AdditionalProperties == nil {
                strct.AdditionalProperties = make(map[string]interface{}, 0)
            }
            strct.AdditionalProperties[k]= additionalValue
        }
    }
    return nil
}

func (strct *Dependency) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal any additional Properties
    for k, v := range strct.AdditionalProperties {
		if comma {
			buf.WriteString(",")
		}
        buf.WriteString(fmt.Sprintf("\"%s\":", k))
		if tmp, err := json.Marshal(v); err != nil {
			return nil, err
		} else {
			buf.Write(tmp)
		}
        comma = true
	}

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Dependency) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        default:
            // an additional "string" value
            var additionalValue string
            if err := json.Unmarshal([]byte(v), &additionalValue); err != nil {
                return err // invalid additionalProperty
            }
            if strct.AdditionalProperties == nil {
                strct.AdditionalProperties = make(map[string]string, 0)
            }
            strct.AdditionalProperties[k]= additionalValue
        }
    }
    return nil
}

func (strct *Engines) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "node" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"node\": ")
	if tmp, err := json.Marshal(strct.Node); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal any additional Properties
    for k, v := range strct.AdditionalProperties {
		if comma {
			buf.WriteString(",")
		}
        buf.WriteString(fmt.Sprintf("\"%s\":", k))
		if tmp, err := json.Marshal(v); err != nil {
			return nil, err
		} else {
			buf.Write(tmp)
		}
        comma = true
	}

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Engines) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "node":
            if err := json.Unmarshal([]byte(v), &strct.Node); err != nil {
                return err
             }
        default:
            // an additional "string" value
            var additionalValue string
            if err := json.Unmarshal([]byte(v), &additionalValue); err != nil {
                return err // invalid additionalProperty
            }
            if strct.AdditionalProperties == nil {
                strct.AdditionalProperties = make(map[string]string, 0)
            }
            strct.AdditionalProperties[k]= additionalValue
        }
    }
    return nil
}

func (strct *Esnext_object) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "browser" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"browser\": ")
	if tmp, err := json.Marshal(strct.Browser); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "main" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"main\": ")
	if tmp, err := json.Marshal(strct.Main); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal any additional Properties
    for k, v := range strct.AdditionalProperties {
		if comma {
			buf.WriteString(",")
		}
        buf.WriteString(fmt.Sprintf("\"%s\":", k))
		if tmp, err := json.Marshal(v); err != nil {
			return nil, err
		} else {
			buf.Write(tmp)
		}
        comma = true
	}

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Esnext_object) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "browser":
            if err := json.Unmarshal([]byte(v), &strct.Browser); err != nil {
                return err
             }
        case "main":
            if err := json.Unmarshal([]byte(v), &strct.Main); err != nil {
                return err
             }
        default:
            // an additional "string" value
            var additionalValue string
            if err := json.Unmarshal([]byte(v), &additionalValue); err != nil {
                return err // invalid additionalProperty
            }
            if strct.AdditionalProperties == nil {
                strct.AdditionalProperties = make(map[string]string, 0)
            }
            strct.AdditionalProperties[k]= additionalValue
        }
    }
    return nil
}

func (strct *FundingWay) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "type" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"type\": ")
	if tmp, err := json.Marshal(strct.Type); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Url" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "url" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"url\": ")
	if tmp, err := json.Marshal(strct.Url); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *FundingWay) UnmarshalJSON(b []byte) error {
    urlReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "type":
            if err := json.Unmarshal([]byte(v), &strct.Type); err != nil {
                return err
             }
        case "url":
            if err := json.Unmarshal([]byte(v), &strct.Url); err != nil {
                return err
             }
            urlReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if url (a required property) was received
    if !urlReceived {
        return errors.New("\"url\" is required but was not present")
    }
    return nil
}

func (strct *PackageExportsEntryObject) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "default" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"default\": ")
	if tmp, err := json.Marshal(strct.Default); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "import" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"import\": ")
	if tmp, err := json.Marshal(strct.Import); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "node" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"node\": ")
	if tmp, err := json.Marshal(strct.Node); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "require" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"require\": ")
	if tmp, err := json.Marshal(strct.Require); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "types" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"types\": ")
	if tmp, err := json.Marshal(strct.Types); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *PackageExportsEntryObject) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "default":
            if err := json.Unmarshal([]byte(v), &strct.Default); err != nil {
                return err
             }
        case "import":
            if err := json.Unmarshal([]byte(v), &strct.Import); err != nil {
                return err
             }
        case "node":
            if err := json.Unmarshal([]byte(v), &strct.Node); err != nil {
                return err
             }
        case "require":
            if err := json.Unmarshal([]byte(v), &strct.Require); err != nil {
                return err
             }
        case "types":
            if err := json.Unmarshal([]byte(v), &strct.Types); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *PeerDependenciesMetaItem) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "optional" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"optional\": ")
	if tmp, err := json.Marshal(strct.Optional); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal any additional Properties
    for k, v := range strct.AdditionalProperties {
		if comma {
			buf.WriteString(",")
		}
        buf.WriteString(fmt.Sprintf("\"%s\":", k))
		if tmp, err := json.Marshal(v); err != nil {
			return nil, err
		} else {
			buf.Write(tmp)
		}
        comma = true
	}

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *PeerDependenciesMetaItem) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "optional":
            if err := json.Unmarshal([]byte(v), &strct.Optional); err != nil {
                return err
             }
        default:
            // an additional "interface{}" value
            var additionalValue interface{}
            if err := json.Unmarshal([]byte(v), &additionalValue); err != nil {
                return err // invalid additionalProperty
            }
            if strct.AdditionalProperties == nil {
                strct.AdditionalProperties = make(map[string]interface{}, 0)
            }
            strct.AdditionalProperties[k]= additionalValue
        }
    }
    return nil
}

func (strct *Person_object) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "email" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"email\": ")
	if tmp, err := json.Marshal(strct.Email); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Name" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "name" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"name\": ")
	if tmp, err := json.Marshal(strct.Name); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "url" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"url\": ")
	if tmp, err := json.Marshal(strct.Url); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Person_object) UnmarshalJSON(b []byte) error {
    nameReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "email":
            if err := json.Unmarshal([]byte(v), &strct.Email); err != nil {
                return err
             }
        case "name":
            if err := json.Unmarshal([]byte(v), &strct.Name); err != nil {
                return err
             }
            nameReceived = true
        case "url":
            if err := json.Unmarshal([]byte(v), &strct.Url); err != nil {
                return err
             }
        }
    }
    // check if name (a required property) was received
    if !nameReceived {
        return errors.New("\"name\" is required but was not present")
    }
    return nil
}

func (strct *PublishConfig) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "access" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"access\": ")
	if tmp, err := json.Marshal(strct.Access); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "registry" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"registry\": ")
	if tmp, err := json.Marshal(strct.Registry); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "tag" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"tag\": ")
	if tmp, err := json.Marshal(strct.Tag); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal any additional Properties
    for k, v := range strct.AdditionalProperties {
		if comma {
			buf.WriteString(",")
		}
        buf.WriteString(fmt.Sprintf("\"%s\":", k))
		if tmp, err := json.Marshal(v); err != nil {
			return nil, err
		} else {
			buf.Write(tmp)
		}
        comma = true
	}

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *PublishConfig) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "access":
            if err := json.Unmarshal([]byte(v), &strct.Access); err != nil {
                return err
             }
        case "registry":
            if err := json.Unmarshal([]byte(v), &strct.Registry); err != nil {
                return err
             }
        case "tag":
            if err := json.Unmarshal([]byte(v), &strct.Tag); err != nil {
                return err
             }
        default:
            // an additional "interface{}" value
            var additionalValue interface{}
            if err := json.Unmarshal([]byte(v), &additionalValue); err != nil {
                return err // invalid additionalProperty
            }
            if strct.AdditionalProperties == nil {
                strct.AdditionalProperties = make(map[string]interface{}, 0)
            }
            strct.AdditionalProperties[k]= additionalValue
        }
    }
    return nil
}

func (strct *Scripts) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "install" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"install\": ")
	if tmp, err := json.Marshal(strct.Install); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "lint" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"lint\": ")
	if tmp, err := json.Marshal(strct.Lint); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "postinstall" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"postinstall\": ")
	if tmp, err := json.Marshal(strct.Postinstall); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "postpack" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"postpack\": ")
	if tmp, err := json.Marshal(strct.Postpack); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "postpublish" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"postpublish\": ")
	if tmp, err := json.Marshal(strct.Postpublish); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "postrestart" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"postrestart\": ")
	if tmp, err := json.Marshal(strct.Postrestart); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "poststart" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"poststart\": ")
	if tmp, err := json.Marshal(strct.Poststart); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "poststop" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"poststop\": ")
	if tmp, err := json.Marshal(strct.Poststop); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "posttest" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"posttest\": ")
	if tmp, err := json.Marshal(strct.Posttest); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "postuninstall" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"postuninstall\": ")
	if tmp, err := json.Marshal(strct.Postuninstall); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "postversion" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"postversion\": ")
	if tmp, err := json.Marshal(strct.Postversion); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "preinstall" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"preinstall\": ")
	if tmp, err := json.Marshal(strct.Preinstall); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "prepack" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"prepack\": ")
	if tmp, err := json.Marshal(strct.Prepack); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "prepare" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"prepare\": ")
	if tmp, err := json.Marshal(strct.Prepare); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "prepublish" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"prepublish\": ")
	if tmp, err := json.Marshal(strct.Prepublish); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "prepublishOnly" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"prepublishOnly\": ")
	if tmp, err := json.Marshal(strct.PrepublishOnly); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "prerestart" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"prerestart\": ")
	if tmp, err := json.Marshal(strct.Prerestart); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "prestart" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"prestart\": ")
	if tmp, err := json.Marshal(strct.Prestart); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "prestop" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"prestop\": ")
	if tmp, err := json.Marshal(strct.Prestop); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "pretest" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"pretest\": ")
	if tmp, err := json.Marshal(strct.Pretest); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "preuninstall" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"preuninstall\": ")
	if tmp, err := json.Marshal(strct.Preuninstall); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "preversion" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"preversion\": ")
	if tmp, err := json.Marshal(strct.Preversion); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "publish" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"publish\": ")
	if tmp, err := json.Marshal(strct.Publish); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "restart" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"restart\": ")
	if tmp, err := json.Marshal(strct.Restart); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "serve" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"serve\": ")
	if tmp, err := json.Marshal(strct.Serve); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "start" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"start\": ")
	if tmp, err := json.Marshal(strct.Start); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "stop" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"stop\": ")
	if tmp, err := json.Marshal(strct.Stop); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "test" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"test\": ")
	if tmp, err := json.Marshal(strct.Test); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "uninstall" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"uninstall\": ")
	if tmp, err := json.Marshal(strct.Uninstall); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "version" field
    if comma {
        buf.WriteString(",")
    }
    buf.WriteString("\"version\": ")
	if tmp, err := json.Marshal(strct.Version); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal any additional Properties
    for k, v := range strct.AdditionalProperties {
		if comma {
			buf.WriteString(",")
		}
        buf.WriteString(fmt.Sprintf("\"%s\":", k))
		if tmp, err := json.Marshal(v); err != nil {
			return nil, err
		} else {
			buf.Write(tmp)
		}
        comma = true
	}

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Scripts) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "install":
            if err := json.Unmarshal([]byte(v), &strct.Install); err != nil {
                return err
             }
        case "lint":
            if err := json.Unmarshal([]byte(v), &strct.Lint); err != nil {
                return err
             }
        case "postinstall":
            if err := json.Unmarshal([]byte(v), &strct.Postinstall); err != nil {
                return err
             }
        case "postpack":
            if err := json.Unmarshal([]byte(v), &strct.Postpack); err != nil {
                return err
             }
        case "postpublish":
            if err := json.Unmarshal([]byte(v), &strct.Postpublish); err != nil {
                return err
             }
        case "postrestart":
            if err := json.Unmarshal([]byte(v), &strct.Postrestart); err != nil {
                return err
             }
        case "poststart":
            if err := json.Unmarshal([]byte(v), &strct.Poststart); err != nil {
                return err
             }
        case "poststop":
            if err := json.Unmarshal([]byte(v), &strct.Poststop); err != nil {
                return err
             }
        case "posttest":
            if err := json.Unmarshal([]byte(v), &strct.Posttest); err != nil {
                return err
             }
        case "postuninstall":
            if err := json.Unmarshal([]byte(v), &strct.Postuninstall); err != nil {
                return err
             }
        case "postversion":
            if err := json.Unmarshal([]byte(v), &strct.Postversion); err != nil {
                return err
             }
        case "preinstall":
            if err := json.Unmarshal([]byte(v), &strct.Preinstall); err != nil {
                return err
             }
        case "prepack":
            if err := json.Unmarshal([]byte(v), &strct.Prepack); err != nil {
                return err
             }
        case "prepare":
            if err := json.Unmarshal([]byte(v), &strct.Prepare); err != nil {
                return err
             }
        case "prepublish":
            if err := json.Unmarshal([]byte(v), &strct.Prepublish); err != nil {
                return err
             }
        case "prepublishOnly":
            if err := json.Unmarshal([]byte(v), &strct.PrepublishOnly); err != nil {
                return err
             }
        case "prerestart":
            if err := json.Unmarshal([]byte(v), &strct.Prerestart); err != nil {
                return err
             }
        case "prestart":
            if err := json.Unmarshal([]byte(v), &strct.Prestart); err != nil {
                return err
             }
        case "prestop":
            if err := json.Unmarshal([]byte(v), &strct.Prestop); err != nil {
                return err
             }
        case "pretest":
            if err := json.Unmarshal([]byte(v), &strct.Pretest); err != nil {
                return err
             }
        case "preuninstall":
            if err := json.Unmarshal([]byte(v), &strct.Preuninstall); err != nil {
                return err
             }
        case "preversion":
            if err := json.Unmarshal([]byte(v), &strct.Preversion); err != nil {
                return err
             }
        case "publish":
            if err := json.Unmarshal([]byte(v), &strct.Publish); err != nil {
                return err
             }
        case "restart":
            if err := json.Unmarshal([]byte(v), &strct.Restart); err != nil {
                return err
             }
        case "serve":
            if err := json.Unmarshal([]byte(v), &strct.Serve); err != nil {
                return err
             }
        case "start":
            if err := json.Unmarshal([]byte(v), &strct.Start); err != nil {
                return err
             }
        case "stop":
            if err := json.Unmarshal([]byte(v), &strct.Stop); err != nil {
                return err
             }
        case "test":
            if err := json.Unmarshal([]byte(v), &strct.Test); err != nil {
                return err
             }
        case "uninstall":
            if err := json.Unmarshal([]byte(v), &strct.Uninstall); err != nil {
                return err
             }
        case "version":
            if err := json.Unmarshal([]byte(v), &strct.Version); err != nil {
                return err
             }
        default:
            // an additional "string" value
            var additionalValue string
            if err := json.Unmarshal([]byte(v), &additionalValue); err != nil {
                return err // invalid additionalProperty
            }
            if strct.AdditionalProperties == nil {
                strct.AdditionalProperties = make(map[string]string, 0)
            }
            strct.AdditionalProperties[k]= additionalValue
        }
    }
    return nil
}
